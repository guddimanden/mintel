import sys
import re
import socket
import concurrent.futures
import signal
import time
from tqdm import tqdm

# Global variable to store filtered IP addresses
filtered_ips = []

def is_docker_running(ip):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(1)
        s.connect((ip, int(sys.argv[3])))
        s.sendall("GET\n\r".encode())
        time.sleep(1)
        response = s.recv(2048)
        s.close()
        if b'Server: thttpd/2.25b' in response:
            print(ip)
            return True
        else:
            return False
    except:
        return False

def signal_handler(sig, frame):
    print("\nCtrl+C detected. Saving filtered IP addresses...")
    with open("filtered_ips.txt", 'w') as output_file:
        for ip in filtered_ips:
            output_file.write(ip + "\n")
    sys.exit(0)

def filter_ip(ip):
    if is_docker_running(ip):
        filtered_ips.append(ip)

def main():
    if len(sys.argv) < 3:
        print("Usage: python script.py <input_filename> <output_filename>")
        sys.exit(1)

    input_filename = sys.argv[1]
    output_filename = sys.argv[2]

    with open(input_filename, 'r') as file:
        lines = file.readlines()

    ip_pattern = re.compile(r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b')

    # Set up Ctrl+C signal handler
    signal.signal(signal.SIGINT, signal_handler)

    with concurrent.futures.ThreadPoolExecutor(max_workers=512) as executor:
        future_to_ip = {executor.submit(filter_ip, ip_match.group(0)): ip_match.group(0) for line in lines for ip_match in [ip_pattern.search(line)] if ip_match}
        for _ in tqdm(concurrent.futures.as_completed(future_to_ip), total=len(future_to_ip), desc="Filtering IPs"):
            pass

    # Write filtered IP addresses to the output file
    with open(output_filename, 'w') as output_file:
        for ip in filtered_ips:
            output_file.write(ip + "\n")
            print(ip)

if __name__ == "__main__":
    main()
